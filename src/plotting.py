"""Utilities for making plots with your data.

BNF
---

.. highlight:: none

.. literalinclude:: ../../doc/bnf/plotting.bnf

Parameter notes
---------------

pisa-section
''''''''''''

You can specify either a file of PISA data or a custom array.
If you give a file, you need to be very careful about coordinates!
See the documentation for loadPisa for the coordinate convention used
to make PISA plots.

h5-name
    The name of a PISA hdf5 file, generated by
    :py:mod:`interpretPisa<bpreveal.interpretPisa>`. Cannot be used if
    ``values`` is present.

values
    Instead of giving a PISA file, give an array of values to plot. These
    should already be sheared and in the form generated by
    :py:func:`loadPisa<bpreveal.plotting.loadPisa>`. It will be an array of
    shape (num-regions, num-regions). Cannot be used if ``h5-name`` is given.
    Note that the cropping (in ``coordinates``) is applied *to* this array, so
    it should represent the data for the whole window and then the plotting
    functions will crop in appropriately.

coordinates-section
'''''''''''''''''''

genome-fasta
    The name of a fasta-format file containing the genome of the organism. The
    relevant sequence information will be extracted based on
    ``genome-window-start`` and ``genome-window-chrom``. Cannot be used if
    ``sequence`` is provided.

sequence
    Instead of looking up the sequence in a fasta, you can provide it manually.
    This should be a string of ``A``, ``C``, ``G``, and ``T``, and it must have
    the same length as the shape of the values array (or, equivalently, the
    number of regions in your pisa hdf5 file).
    Default: If no sequence is provided, then you cannot use ``show-sequence``
    in the importance or prediction sections.

midpoint-offset
    For making a plot, how far from the left edge of the pisa data do you want
    the middle of the plot to be? For example, if your pisa data start at
    coordinate 131,500 and you want coordinate 132,000 to be in the middle of
    the plot, you'd set ``"midpoint-offset": 500``.

input-slice-width, output-slice-width
    How wide of a region do you want to be plotted? ``input-slice-width``
    determines the width of the x-axis. Use a smaller value to see the effect
    of fewer and fewer bases. ``output-slice-width`` determines the height of
    the y-axis. Use smaller values to zoom in on local effects.

genome-window-start, genome-window-chrom
    These are used to set the values for the tick labels on the plots,
    and also to extract the sequence from a fasta file if you provided
    ``genome-fasta``.

profile-section
'''''''''''''''

The profile section gives the data that should be plotted in the importance score
or prediction tracks. The format for both tracks is identical.

bigwig-name
    The name of the bigwig file to read from. Data will be extracted based on
    ``genome-window-start`` and ``genome-window-chrom``. Cannot be used with
    ``values``.

values
    An array of shape (num-regions) containing the profile values to use at
    each base, starting at ``genome-window-start``.

show-sequence
    If true, then draw the actual letters of the DNA sequence to represent the
    profile. If false, then draw a bar plot like in IGV.
    Default: False

color
    Color, for a profile, can be one of several things. It can be a single
    ``color-spec``, or a dictionary with one ``color-spec`` for each DNA base.
    Alternatively, it can be a list of ``color-spec`` (or dictionary with one
    ``color-spec`` for each base) with one entry for each position in the profile.
    This way, you can color each bar (or each letter in the logo) a different
    color. See the py:class:`ColorMaps<bpreveal.plotting.ColorMaps>` documentation
    for a description of color-specs.
    Default: If ``show-sequence`` is ``true``, then the default Wong color map
    for bases. If ``show-sequence`` is ``false``, then Tol color 0.

annotation-section
''''''''''''''''''

Annotations are used to label specific areas of the plot, typically with
things like motifs and genes.

bed-name
    If you scanned for motifs, then you can give a bed file here.
    Hits in that bed file will be drawn on the plot.
    Default: Do not read in a bed file.

name-colors
    In order to provide a consistent color to each named motif, you can
    specify which names get which colors. It is a simple dict mapping
    names (e.g., "Abf1") to colorSpecs. Whenever an entry from the bed
    file is drawn, the code will check to see if that entry's name appears
    in this dict. If it does, then that color will be used to draw its
    annotation box.
    Default: Assign colors as names are encountered.

custom
    A list of annotations that you provide that do not come from the bed file.
    An annotation is a simple dict mapping ``start`` and ``end`` to (genomic)
    coordinates, along with a ``name`` giving the text to draw and a
    ``color`` giving a colorSpec to use. See
    :py:class:`ColorMaps<bpreveal.plotting.ColorMaps>` for colorSpec
    documentation.
    Default: No custom annotations.

figure-section
''''''''''''''

bottom, left, width, height
    Where on the given figure should the plot be placed? Note that axis labels
    and other text can overflow this bounding box. For figure prep, you'll
    likely have to tweak these parameters.

annotation-height
    How tall, as a fraction of the total height allocated for annotations,
    should the drawn boxes be? Note that some extra space will be placed
    between the boxes for clarity. For large figures, you'll probably want to
    make this smaller.
    Default: 0.13

tick-font-size, label-font-size
    For coordinate ticks and text labels, what font size should be used?
    Defaults: ``tick-font-size`` defaults to 6 and ``label-font-size`` defaults to 8.

color-span
    This sets the color limit for pisa values. If a clipping color map
    is used, then any values above this will show as clipped colors.

grid-mode, diagonal-mode
    For pisa plots only (not pisa graphs), these parameters determine whether
    or not the grid lines and diagonal line should be drawn. ``grid-mode`` can
    be either ``"on"`` or ``"off"``, while ``diagonal-mode`` can be one of
    ``"on"``, ``"off"``, or ``"edge"``. ``edge`` means that the diagonal lines
    should only be drawn at the border of the pisa plot, like inward-facing
    axis ticks.
    Defaults: ``grid-mode`` defaults to ``"on"`` and
    ``diagonal-mode`` defaults to ``"edge"``.

line-width
    For PISA graphs only (not plots). This sets the width of the lines that
    connect the cause to effect. For large images, increasing this reduces
    Moir√© interference.
    Default: 1.0

Plot-specific parameters
''''''''''''''''''''''''

min-value
    Only applicable to PISA graphs, not plots.
    If (the absolute value of) a PISA entry between two bases
    is less than min-value, no line will be drawn at all.
    I recommend keeping this at about the 95th percentile
    of your PISA data, as otherwise an absolutely enormous number of
    splines will be drawn.

use-annotation-colors
    Only applicable to PISA graphs.
    If ``true``, then any splines that originate from a base that
    overlaps with an annotation will be drawn in the color of that
    annotation instead of the normal color map. This is useful
    for showing the effects of different motifs, for example.
    If ``false``, then all splines will use the default color map
    based on the PISA value between the bases they connect.
    Default: ``false``.

miniature
    Only applicable to PISA plots, not graphs. If ``true``, then the format of
    the graph is changed to make it better-suited to one-column figures. The
    text for annotations is moved to a legend, and the axis labels are
    simplified.
    Default: ``false``.

Module contents
---------------

"""
import math
from typing import TypeAlias, Literal, TypedDict
import h5py
import pysam
import pyBigWig
import pybedtools
import numpy as np

import matplotlib.pyplot as plt
import matplotlib as mpl
import matplotlib.figure
from matplotlib import patches
from matplotlib.path import Path
from matplotlib.axes import Axes as AXES_T
from matplotlib.transforms import Bbox, Affine2D
from matplotlib.font_manager import FontProperties
from matplotlib.textpath import TextPath
from matplotlib.patches import PathPatch
from matplotlib.cm import ScalarMappable
import matplotlib.colors as mplcolors
import matplotlib.ticker as mplticker


from bpreveal import logUtils
from bpreveal.internal.constants import IMPORTANCE_AR_T, PRED_AR_T, ONEHOT_AR_T
from bpreveal import utils
from bpreveal import motifUtils
from bpreveal import schema
from bpreveal.colors import COLOR_SPEC_T, DNA_COLOR_SPEC_T, RGB_T, ColorMaps

FONT_FAMILY = "serif"
FONT_SIZE_TICKS = 6
FONT_SIZE_LABELS = 8


def plotPisaGraph(config: dict, fig: matplotlib.figure.Figure, validate: bool = True):
    r"""Make a graph-style PISA plot.

    :param config: The JSON (or any dictionary, really) configuration for this PISA plot.
    :param fig: The matplotlib figure that will be drawn on.
    :param validate: Should the configuration be checked? If you're passing in numpy
        arrays, the json validator is prone to exploding.
    :return: A dictionary containing the created Axes objects, the assigned colors for
        annotations, and the genomic coordinates is the plot.

    The structure of the returned dict is:

    .. highlight:: none

    ::

        {"axes": {"pisa": matplotlib.axes,
                  "importance": matplotlib.axes,
                  "predictions": matplotlib.axes,
                  "annotations": matplotlib.axes}
            "name-colors": Same structure as the config dict, but with missing entries added.
            "genome-start": int,
            "genome-end": int,
            "config": config dict with data loaded.}

    .. highlight:: python

    Example::

        fig = plt.figure(figsize=(7,4))
        pisaSection = {"h5-name": f"{WORK_DIR}/shap/pisa_nanog_positive.h5"}

        coordinatesSection = {
            "genome-fasta": GENOME_FASTA,
            "midpoint-offset": 1150,
            "input-slice-width": 200,
            "output-slice-width": 500,
            "genome-window-start": windowStart,
            "genome-window-chrom": windowChrom
        }

        predictionSection = {"bigwig-name": f"{WORK_DIR}/pred/nanog_residual_positive.bw"}

        importanceSection = {
            "bigwig-name": f"{WORK_DIR}/shap/nanog_profile.bw",
            "show-sequence": True
        }

        annotationSection = {"bed-name": f"{WORK_DIR}/scan/nanog_profile.bed"}

        figureSectionGraph = {
            "left": 0.12,
            "bottom": 0.13,
            "width": 0.8,
            "height": 0.85,
            "color-span": 0.5,
        }

        graphConfig = {
            "pisa": pisaSection,
            "coordinates": coordinatesSection,
            "importance": importanceSection,
            "predictions": predictionSection,
            "annotations": annotationSection,
            "figure": figureSectionGraph,
            "min-value": 0.1,
            "use-annotation-colors": False
        }

        bpreveal.plotting.plotPisaGraph(graphConfig, fig);

    This code produces a graph that looks like this:

    .. image:: ../../doc/presentations/pisaGraph.png
        :width: 800
        :alt: Representative pisa graph.

    """
    if validate:
        schema.pisaGraph.validate(config)
    cfg = _buildConfig(config)
    del config  # Don't accidentally use the old one.
    logUtils.debug("Starting to draw PISA graph.")

    axGraph, axSeq, axProfile, axAnnot, axCbar = _getPisaGraphAxes(fig,
                                                                   cfg["figure"]["left"],
                                                                   cfg["figure"]["bottom"],
                                                                   cfg["figure"]["width"],
                                                                   cfg["figure"]["height"])
    coords = cfg["coordinates"]
    sliceStart = coords["midpoint-offset"] - coords["input-slice-width"] // 2
    sliceEnd = sliceStart + coords["input-slice-width"]
    genomeStart = coords["genome-window-start"] + sliceStart
    genomeEnd = coords["genome-window-start"] + sliceEnd

    shearMat = cfg["pisa"]["values"][sliceStart:sliceEnd, sliceStart:sliceEnd]
    colorBlocks = []
    if cfg["use-annotation-colors"]:
        for annot in cfg["annotations"]["custom"]:
            colorBlocks.append((annot["start"] - genomeStart,
                                annot["end"] - genomeStart,
                                annot["color"]))
    logUtils.debug("Axes set. Drawing graph.")
    pisaCax = _addPisaGraph(similarityMat=shearMat, minValue=cfg["min-value"],
                  colorSpan=cfg["figure"]["color-span"], colorBlocks=colorBlocks,
                  lineWidth=cfg["figure"]["line-width"],
                  ax=axGraph)

    # Now set up the sequence/importance axis.
    logUtils.debug("Graph complete. Finishing plot.")
    _addHorizontalProfilePlot(cfg["importance"]["values"][sliceStart:sliceEnd],
                              cfg["importance"]["color"][sliceStart:sliceEnd],
                              coords["sequence"][sliceStart:sliceEnd],
                              genomeStart,
                              genomeEnd,
                              axSeq, axGraph,
                              cfg["figure"]["tick-font-size"],
                              cfg["figure"]["label-font-size"],
                              cfg["importance"]["show-sequence"],
                              True, False)

    _addAnnotations(axAnnot, cfg["annotations"]["custom"],
                    cfg["figure"]["annotation-height"], genomeStart, genomeEnd,
                    coords["input-slice-width"],
                    cfg["figure"]["label-font-size"], False)

    # Now, add the profiles.
    _addHorizontalProfilePlot(cfg["predictions"]["values"][sliceStart:sliceEnd],
                              cfg["predictions"]["color"][sliceStart:sliceEnd],
                              coords["sequence"][sliceStart:sliceEnd],
                              genomeStart,
                              genomeEnd,
                              axProfile, None,
                              cfg["figure"]["tick-font-size"],
                              cfg["figure"]["label-font-size"],
                              cfg["predictions"]["show-sequence"],
                              False, False)

    _addCbar(pisaCax, axCbar, cfg["figure"]["label-font-size"], False)
    logUtils.debug("PISA graph complete.")
    return {"axes": {"graph": axGraph, "importance": axSeq, "predictions": axProfile,
                     "annotations": axAnnot},
            "name-colors": cfg["annotations"].get("name-colors", {}),
            "genome-start": genomeStart,
            "genome-end": genomeEnd,
            "config": cfg}


def plotPisa(config: dict, fig: matplotlib.figure.Figure, validate: bool = True):
    r"""Given the actual vectors to show, make a pretty pisa plot.

    :param config: The JSON (or any dictionary, really) configuration for this PISA plot.
    :param fig: The matplotlib figure that will be drawn on.
    :param validate: Should the configuration be checked? If you're passing in numpy
        arrays, the json validator is prone to exploding.
    :return: A dict containing the generated axes, along with the assigned name colors and
        the coordinates that were plotted.

    The returned dict will have the following structure:

    .. highlight:: none

    ::

        {"axes": {"pisa": matplotlib.axes,
                  "importance": matplotlib.axes,
                  "predictions": matplotlib.axes,
                  "annotations": matplotlib.axes}
            "name-colors": Same structure as the config dict, but with missing entries added.
            "genome-start": int,
            "genome-end": int,
            "config": config dict with data loaded}

    .. highlight:: python

    Example::

        fig = plt.figure(figsize=(7,4))

        pisaSection = {"h5-name": f"{WORK_DIR}/shap/pisa_nanog_positive.h5"}

        coordinatesSection = {
            "genome-fasta": GENOME_FASTA,
            "midpoint-offset": 1150,
            "input-slice-width": 200,
            "output-slice-width": 500,
            "genome-window-start": windowStart,
            "genome-window-chrom": windowChrom
        }

        predictionSection = {"bigwig-name": f"{WORK_DIR}/pred/nanog_residual_positive.bw"}

        importanceSection = {
            "bigwig-name": f"{WORK_DIR}/shap/nanog_profile.bw",
            "show-sequence": True
        }

        annotationSection = {"bed-name": f"{WORK_DIR}/scan/nanog_profile.bed"}

        figureSectionPlot = {
            "left": 0.12,
            "bottom": 0.13,
            "width": 0.8,
            "height": 0.85,
            "color-span" : 0.5,
        }

        plotConfig = {
            "pisa": pisaSection,
            "coordinates": coordinatesSection,
            "importance": importanceSection,
            "predictions": predictionSection,
            "annotations": annotationSection,
            "figure": figureSectionPlot
        }

        bpreveal.plotting.plotPisa(plotConfig, fig)

    This code produces a plot that looks like this:

    .. image:: ../../doc/presentations/pisaPlot.png
        :width: 800
        :alt: Representative pisa plot.

    """
    if validate:
        schema.pisaPlot.validate(config)
    cfg = _buildConfig(config)
    del config  # Don't accidentally edit the old one.
    logUtils.debug("Starting to draw PISA graph.")

    axPisa, axSeq, axProfile, axCbar, axAnnot, axLegend = _getPisaAxes(
        fig, cfg["figure"]["left"], cfg["figure"]["bottom"],
        cfg["figure"]["width"], cfg["figure"]["height"],
        cfg["miniature"])
    # Pisa image plotting
    coords = cfg["coordinates"]
    sliceStartX = coords["midpoint-offset"] - coords["input-slice-width"] // 2
    sliceEndX = sliceStartX + coords["input-slice-width"]
    sliceStartY = coords["midpoint-offset"] - coords["output-slice-width"] // 2
    sliceEndY = sliceStartY + coords["output-slice-width"]
    genomeStartX = coords["genome-window-start"] + sliceStartX
    genomeEndX = coords["genome-window-start"] + sliceEndX
    shearMat = np.copy(cfg["pisa"]["values"][sliceStartY:sliceEndY, sliceStartX:sliceEndX])
    colorBlocks = []
    for annot in cfg["annotations"]["custom"]:
        colorBlocks.append((annot["start"] - coords["genome-window-start"],
                            annot["end"] - coords["genome-window-start"],
                            annot["color"]))
    logUtils.debug("Axes set. Drawing graph.")
    pisaCax = _addPisaPlot(shearMat, cfg["figure"]["color-span"], axPisa,
                           cfg["figure"]["diagonal-mode"], cfg["figure"]["grid-mode"],
                           cfg["figure"]["tick-font-size"], cfg["figure"]["label-font-size"],
                           genomeStartX, cfg["miniature"])
    # Now set up the sequence/importance axis.
    logUtils.debug("Graph complete. Finishing plot.")
    _addHorizontalProfilePlot(cfg["importance"]["values"][sliceStartX:sliceEndX],
                              cfg["importance"]["color"][sliceStartX:sliceEndX],
                              coords["sequence"][sliceStartX:sliceEndX],
                              genomeStartX,
                              genomeEndX,
                              axSeq, axPisa,
                              cfg["figure"]["tick-font-size"],
                              cfg["figure"]["label-font-size"],
                              cfg["importance"]["show-sequence"],
                              True, cfg["miniature"])

    usedNames = _addAnnotations(axAnnot, cfg["annotations"]["custom"],
                                cfg["figure"]["annotation-height"], genomeStartX,
                                genomeEndX, coords["input-slice-width"],
                                cfg["figure"]["label-font-size"], False)
    # Now, add the profiles.
    _addVerticalProfilePlot(cfg["predictions"]["values"][sliceStartY:sliceEndY],
                            axProfile,
                            cfg["predictions"]["color"][sliceStartY:sliceEndY],
                            coords["sequence"][sliceStartY:sliceEndY],
                            cfg["figure"]["tick-font-size"],
                            cfg["predictions"]["show-sequence"],
                            cfg["miniature"])
    if axLegend is not None:
        _addLegend(usedNames, axLegend, cfg["figure"]["label-font-size"])
    _addCbar(pisaCax, axCbar, cfg["figure"]["label-font-size"], cfg["miniature"])
    return {"axes": {"pisa": axPisa, "importance": axSeq, "predictions": axProfile,
                     "annotations": axAnnot, "colorbar": axCbar,
                     "legend": axLegend},
            "name-colors": cfg["annotations"].get("name-colors", {}),
            "genome-start": genomeStartX,
            "genome-end": genomeEndX,
            "config": cfg}


def plotModiscoPattern(pattern: motifUtils.Pattern,  # pylint: disable=too-many-statements
                       fig: matplotlib.figure.Figure, sortKey=None):
    """Create a plot showing a pattern's seqlets and their match scores.

    :param sortKey: Either None (do not sort) or an array of shape (numSeqlets,)
        giving the order in which the seqlets should be displayed. See example below
        for common use cases.
    :type sortKey: None or ndarray
    :param pattern: The pattern to plot. This pattern must have already had its seqlets loaded.
    :param fig: The matplotlib figure upon which the plots should be drawn.

    Example::

        # Background ACGT frequency
        bgProbs = [0.291, 0.208, 0.208, 0.291]
        patSox2 = motifUtils.Pattern("pos_patterns", "pattern_0", "Sox2")
        with h5py.File(f"{WORK_DIR}/modisco/sox2_profile/modisco.h5", "r") as fp:
            patSox2.loadCwm(fp, 0.3, 0.3, bgProbs)
            patSox2.loadSeqlets(fp)
        fig = plt.figure(figsize=(5, 5))
        # Sort the seqlets by their contribution match.
        sortKey = [x.contribMatch for x in patSox2.seqlets]
        plotModiscoPattern(patSox2, fig, sortKey=sortKey)

    This produces the following plot:

    .. image:: ../../doc/presentations/modiscoPattern.png
        :width: 800
        :alt: Representative modisco pattern plot.

    """
    if sortKey is None:
        sortKey = np.arange(len(pattern.seqlets))
    sortOrder = np.argsort(sortKey)
    HIST_HEIGHT = 0.1  # pylint: disable=invalid-name
    PAD = 0.01  # pylint: disable=invalid-name
    axHmap = fig.add_axes((0.1, 0.1 + HIST_HEIGHT + PAD,
                           0.2 - PAD, 0.8 - HIST_HEIGHT))
    hmapAr = np.zeros((len(pattern.seqlets),
                       len(pattern.seqlets[0].sequence),
                       4), dtype=np.uint8)
    for outIdx, seqletIdx in enumerate(sortOrder):
        hmapAr[outIdx] = utils.oneHotEncode(pattern.seqlets[seqletIdx].sequence)
    plotSequenceHeatmap(hmapAr, axHmap)
    axHmap.set_xticks([])
    hmapYticks = axHmap.get_yticks()[1:-1]
    axHmap.set_yticks(hmapYticks, [str(x) for x in hmapYticks], fontsize=FONT_SIZE_TICKS,
                      fontfamily=FONT_FAMILY)
    axLogo = fig.add_axes((0.1, 0.1, 0.2 - PAD, HIST_HEIGHT))
    cwm = pattern.cwm
    plotLogo(cwm, cwm.shape[0], axLogo, colors=ColorMaps.dnaWong)
    axLogo.set_xlim(0, cwm.shape[0])
    cwmPos = np.zeros_like(cwm)
    cwmPos[cwm > 0] = cwm[cwm > 0]
    cwmNeg = np.zeros_like(cwm)
    cwmNeg[cwm < 0] = cwm[cwm < 0]
    sumPos = np.sum(cwmPos, axis=1)
    sumNeg = np.sum(cwmNeg, axis=1)

    axLogo.set_ylim(min(sumNeg), max(sumPos))
    axLogo.set_yticks([])
    axLogo.set_xticks([pattern.cwmTrimLeftPoint, pattern.cwmTrimRightPoint],
                      [str(pattern.cwmTrimLeftPoint), str(pattern.cwmTrimRightPoint)],
                      fontsize=FONT_SIZE_TICKS,
                      fontfamily=FONT_FAMILY)

    yvals = np.arange(len(pattern.seqlets), 0, -1)

    def plotStat(stat, axPos, name, rightTicks):
        stat = np.array(stat)
        axCurStat = fig.add_axes((0.3 + axPos * 0.2, 0.1 + HIST_HEIGHT + PAD,
                                  0.2 - PAD, 0.8 - HIST_HEIGHT))
        statSort = stat[sortOrder]
        colorFix = ColorMaps.parseSpec(ColorMaps.defaultProfile)
        axCurStat.plot(statSort, yvals, ".", color=colorFix, alpha=0.5)
        statFilt = np.sort(statSort)
        colorFix = ColorMaps.parseSpec({"tol": 2})
        axCurStat.plot(statFilt, yvals, "-", color=colorFix)
        axCurStat.set_ylim(0, len(pattern.seqlets))
        axCurStat.set_yticks([])
        axCurStat.set_title(name, fontdict={"fontsize": FONT_SIZE_LABELS,
                                            "fontfamily": FONT_FAMILY})
        axCurStat.set_xticks([])
        axCurStat.set_xlim(min(stat), max(stat))
        tickPoses = np.linspace(0, len(pattern.seqlets), 11, endpoint=True)
        tickLabels = np.arange(0, 110, 10)[::-1]
        axCurStat.tick_params(axis="y", labelleft=False, labelright=rightTicks,
                            left=False, right=rightTicks)
        axCurStat.set_yticks(tickPoses, tickLabels, fontsize=FONT_SIZE_TICKS,
                             fontfamily=FONT_FAMILY)
        axCurStat.grid()
        if rightTicks:
            axCurStat.yaxis.set_label_position("right")
            axCurStat.set_ylabel("Percentile", fontsize=FONT_SIZE_LABELS,
                                 fontfamily=FONT_FAMILY)
        axCurHist = fig.add_axes((0.3 + axPos * 0.2, 0.1, 0.2 - PAD, HIST_HEIGHT))
        hist = np.histogram(stat, bins=50)
        binMiddles = hist[1][:-1] + (hist[1][1] - hist[1][0]) / 2
        axCurHist.plot(binMiddles, hist[0])
        axCurHist.set_yticks([])
        axCurHist.set_xlim(min(stat), max(stat))
        xticks = axCurHist.get_xticks()
        xticks = xticks[1:-1]
        axCurHist.set_xticks(xticks, [str(x) for x in xticks], fontsize=FONT_SIZE_TICKS,
                             fontfamily=FONT_FAMILY)
        return axCurStat
    plotStat([x.seqMatch for x in pattern.seqlets], 0, "seqMatch", False)
    plotStat([x.contribMatch for x in pattern.seqlets], 1, "contribMatch", False)
    plotStat([x.contribMagnitude for x in pattern.seqlets], 2, "contribMag", True)


def plotSequenceHeatmap(hmap: ONEHOT_AR_T, ax: AXES_T, upsamplingFactor: int = 10):
    """Show a sequence heatmap from an array of one-hot encoded sequences.

    :param hmap: An array of sequences of shape (numSequences, length, 4)
    :param ax: A matplotlib Axes object upon which the heatmap will be drawn.
    :param upsamplingFactor: How much should the x-axis be sharpened?
        If upsamplingFactor * hmap.shape[1] >> ax.width_in_pixels then you
        may get aliasing artifacts.
        If upsamplingFactor * hmap.shape[1] << ax.width_in_pixels then you
        will get blurry borders.

    """
    displayAr = np.zeros((hmap.shape[0], hmap.shape[1] * upsamplingFactor, 3),
                         dtype=np.float32)
    for base, baseName in enumerate("ACGT"):
        hmapBase = np.array(hmap[:, :, base], dtype=np.float32)
        ar = hmapBase
        for colorIdx in range(3):
            color = ColorMaps.parseSpec(ColorMaps.dnaWong[baseName])[colorIdx]
            for col in range(hmap.shape[1]):
                for colOffset in range(upsamplingFactor):
                    writeCol = col * upsamplingFactor + colOffset
                    displayAr[:, writeCol, colorIdx] += ar[:, col] * color
    ax.imshow(displayAr, aspect="auto", interpolation="antialiased",
              interpolation_stage="data")


def plotLogo(values: PRED_AR_T, width: float, ax: AXES_T,
             colors: DNA_COLOR_SPEC_T | list[DNA_COLOR_SPEC_T],
             spaceBetweenLetters: float = 0) -> None:
    """Plot an array of sequence data (like a pwm).

    :param values: An (N,4) array of sequence data. This could be, for example,
        a pwm or a one-hot encoded sequence.
    :param width: The width of the total logo, useful for aligning axis labels.
    :param ax: A matplotlib axes object on which the logo will be drawn.
    :param colors: The colors to use for shading the sequence. See below for details.
    :param spaceBetweenLetters: How much should the letters be squished? This is
        given as a fraction of the total letter width. For example, to have
        a gap of 2 pixels between letters that are 10 pixels wide, set
        ``spaceBetweenLetters=0.2``.

    Colors, if provided, can have several meanings:
        1. Give a color for each base type by RGB value.
            In this case, colors will be a dict of tuples:
            ``{"A": (.8, .3, .2), "C": (.5, .3, .9), "G": (1., .4, .0), "T": (1., .7, 0.)}``
            This will make each instance of a particular base have the same color.
        2. Give a color for each base by color-spec.
            This would be something like:
            ``{"A": {"wong": 3}, "C": {"wong": 5}, "G": {"wong": 4}, "T": {"wong": 6}}``
            You can get the default BPReveal color map at :py:class:`~ColorMaps`.
        3. Give a list of colors for each base.
            This will be a list of length ``values.shape[0]`` and each entry
            should be a dictionary in either format
            1 or 2 above. This gives each base its own color palette, useful
              for shading bases by some profile.
    """

    def _drawLetter(text: str, left: float, right: float, bottom: float, top: float,
                    color, ax, flip=False) -> None:

        height = top - bottom
        width = right - left
        bbox = Bbox.from_bounds(left, bottom, width, height)
        fontProperties = FontProperties(family="sans", weight="bold")
        tmpPath = TextPath((0, 0), text, size=1, prop=fontProperties)
        if flip:
            flipTransformation = Affine2D().scale(sx=1, sy=-1)
            # pylint: disable=redefined-variable-type
            tmpPath = flipTransformation.transform_path(tmpPath)
            # pylint: enable=redefined-variable-type
        tmpBbox = tmpPath.get_extents()
        hstretch = bbox.width / tmpBbox.width
        vstretch = bbox.height / tmpBbox.height
        transformation = Affine2D().\
            translate(tx=-tmpBbox.xmin, ty=-tmpBbox.ymin).\
            scale(sx=hstretch, sy=vstretch).\
            translate(tx=bbox.xmin, ty=bbox.ymin)
        charPath = transformation.transform_path(tmpPath)
        patch = PathPatch(charPath, facecolor=color, lw=0.3)
        ax.add_patch(patch)

    def getColor(pos, base):
        match colors:
            case list():
                # Colors is indexed by position.
                return ColorMaps.parseSpec(colors[pos][base])
            case dict():
                return ColorMaps.parseSpec(colors[base])
            case _:
                assert False, "Invalid color spec."

    for predIdx in range(values.shape[0]):
        a, c, g, t = values[predIdx]
        lettersToDraw = [("A", a), ("C", c), ("G", g), ("T", t)]
        posLetters = [x for x in lettersToDraw if x[1] > 0]
        negLetters = [x for x in lettersToDraw if x[1] < 0]
        posLetters.sort(key=lambda x: x[1])
        negLetters.sort(key=lambda x: -x[1])

        # Draw the negative letters.
        top = 0
        for nl in negLetters:
            # Note that top < base because nl[1] < 0
            base = top + nl[1]
            left = predIdx * width / values.shape[0] + spaceBetweenLetters / 2
            right = left + width / values.shape[0] - spaceBetweenLetters
            _drawLetter(nl[0], left=left, right=right, bottom=base, top=top,
                       color=getColor(predIdx, nl[0]), ax=ax, flip=True)
            top = base

        # Draw the positive letters.
        base = 0
        for pl in posLetters:
            top = base + pl[1]
            left = predIdx * width / values.shape[0] + spaceBetweenLetters / 2
            right = left + width / values.shape[0] - spaceBetweenLetters
            _drawLetter(pl[0], left=left, right=right, bottom=base, top=top,
                       color=getColor(predIdx, pl[0]), ax=ax)
            base = top


def getCoordinateTicks(start: int, end: int, numTicks: int,
                       zeroOrigin: bool) -> tuple[list[float], list[str]]:
    """Given a start and end coordinate, return x-ticks that should be used for plotting.

    :param start: The genomic coordinate where your ticks start, inclusive.
    :param end: The genomic coordinate where your ticks end, *inclusive*.
    :param numTicks: The approximate number of ticks you want.
    :param zeroOrigin: The actual x coordinate of the ticks should start
        at zero, even though the labels start at ``start``. Otherwise,
        the ticks will be positioned at coordinate ``start`` to ``end``,
        and so your axes limits should actually correspond to genomic coordinates.
    :return: Two lists. The first is the x-coordinate of the ticks, and the second
        is the string labels that should be used at each tick.

    Given a start and end coordinate, return a list of ticks and tick labels that
    1. include exactly the start and stop coordinates
    2. Contain approximately numTicks positions and labels.
    3. Try to fall on easy multiples 1, 2, and 5 times powers of ten.
    4. Are formatted to reduce redundant label noise by omitting repeated initial digits.
    """
    reverse = False
    if start > end:
        start, end = end, start
        reverse = True
    Œî = abs(end - start)
    tickWidth = 1
    multiplier = 1
    scales = [1, 2, 5]
    scaleIdx = 0
    while tickWidth < Œî / numTicks:
        tickWidth = multiplier * scales[scaleIdx]
        scaleIdx += 1
        if scaleIdx == len(scales):
            multiplier *= 10
            scaleIdx = 0
    multiLoc = mplticker.MultipleLocator(tickWidth)
    multiLoc.view_limits(start, end)
    innerTickPoses = multiLoc.tick_values(start, end)
    while innerTickPoses[0] < start + tickWidth / 2:
        innerTickPoses = innerTickPoses[1:]
    while len(innerTickPoses) and innerTickPoses[-1] > end - tickWidth / 2:
        innerTickPoses = innerTickPoses[:-1]
    tickPoses = [float(x) for x in [start] + list(innerTickPoses) + [end]]
    tickLabelStrs = [f"{int(x):,}" for x in tickPoses]
    if zeroOrigin:
        tickPoses = [x - start for x in tickPoses]
    tickLabels = _massageTickLabels(tickLabelStrs)
    if reverse:
        tickPoses = tickPoses[::-1]
        tickLabels = tickLabels[::-1]
    return tickPoses, tickLabels


def _replaceThousands(labelList: list[str]) -> list[str]:
    """If every label ends with ``,000``, replace the last four letters with ``k``."""
    allThousands = True
    for lbl in labelList[1:-1]:
        if lbl[-4:] != ",000":
            allThousands = False
    labelsThousands = []
    if allThousands:
        for lbl in labelList:
            if lbl[-4:] == ",000":
                labelsThousands.append(lbl[:-4] + "k")
            else:
                labelsThousands.append(lbl)
    else:
        labelsThousands = labelList[:]
    return labelsThousands


def _massageTickLabels(labelList: list[str]) -> list[str]:
    """Remove identical leading digits from labels."""
    labelsThousands = _replaceThousands(labelList)
    for pos in range(len(labelsThousands) - 2, 0, -1):
        prevLabel = labelsThousands[pos - 1]
        curLabel = list(labelsThousands[pos])
        apostrophePos = 0
        for lpos in range(min(len(curLabel), len(prevLabel))):
            if curLabel[lpos] == prevLabel[lpos]:
                if curLabel[lpos] == ",":
                    apostrophePos = lpos
            else:
                break
        if apostrophePos > 1:
            newLabel = "¬¥" + "".join(curLabel[apostrophePos + 1:])
        else:
            newLabel = "".join(curLabel)
        labelsThousands[pos] = newLabel
    return labelsThousands


def _normalizeProfileSection(oldConfig: dict, newConfig: dict, group: str):
    """Take a raw config dict and populate any defaults and load up bigwig data."""
    # Do we need to load bigwig data?
    newConfig[group]["show-sequence"] = oldConfig[group].get("show-sequence", False)
    if "bigwig-name" in oldConfig[group]:
        vals = _loadFromBigwig(oldConfig[group]["bigwig-name"],
                              oldConfig["coordinates"]["genome-window-start"],
                              oldConfig["coordinates"]["genome-window-chrom"],
                              newConfig["pisa"]["values"].shape[1])
        newConfig[group]["values"] = vals
    else:
        newConfig[group]["values"] = np.array(oldConfig[group]["values"])

    # Convert the color spec into a list for each base.
    if newConfig[group]["show-sequence"]:
        backupColor = ColorMaps.dnaWong
    else:
        backupColor = ColorMaps.defaultProfile

    newConfig[group]["color"] = _normalizeProfileColor(
        oldConfig[group].get("color", backupColor),
        len(newConfig[group]["values"]))


def _buildConfig(oldConfig: dict) -> dict:
    r"""Read in a config and add any missing data.

    :param oldConfig: The original configuration dictionary. All entries from this
        original dict are copied, so you can mutate the returned dict without
        messing with the original data.
    This loads in profile and pisa data from files and expands the color specs.
    """
    oldCoords = oldConfig["coordinates"]
    newCoords = {
        "midpoint-offset": oldCoords["midpoint-offset"],
        "input-slice-width": oldCoords["input-slice-width"],
        "output-slice-width": oldCoords["output-slice-width"],
        "genome-window-start": oldCoords["genome-window-start"],
        "genome-window-chrom": oldCoords["genome-window-chrom"]}
    oldFig = oldConfig["figure"]
    newFig = oldFig.copy()  # Bring over (left, bottom, width, height)
    newFig["annotation-height"] = oldFig.get("annotation-height", 0.13)
    newFig["tick-font-size"] = oldFig.get("tick-font-size", FONT_SIZE_TICKS)
    newFig["label-font-size"] = oldFig.get("label-font-size", FONT_SIZE_LABELS)
    newFig["line-width"] = oldFig.get("line-width", 1)

    newConfig = {
        "pisa": {},
        "coordinates": newCoords,
        "predictions": {},
        "importance": {},
        "annotations": {},
        "figure": newFig}

    if "min-value" in oldConfig:
        # We have a graph-style config.
        newConfig["min-value"] = oldConfig["min-value"]
        newConfig["use-annotation-colors"] = oldConfig.get("use-annotation-colors", False)
    else:
        # We have a plot-style config.
        newConfig["miniature"] = oldConfig.get("miniature", False)
        newFig["grid-mode"] = oldFig.get("grid-mode", "on")
        newFig["diagonal-mode"] = oldFig.get("diagonal-mode", "edge")

    # First, the pisa data.
    if "h5-name" in oldConfig["pisa"]:
        # We need to load from file.
        newConfig["pisa"]["values"] = utils.loadPisa(oldConfig["pisa"]["h5-name"])
    else:
        newConfig["pisa"]["values"] = np.array(oldConfig["pisa"]["values"])

    _normalizeProfileSection(oldConfig, newConfig, "importance")
    _normalizeProfileSection(oldConfig, newConfig, "predictions")

    newConfig["annotations"]["custom"] = oldConfig["annotations"].get("custom", [])
    if "bed-name" in oldConfig["annotations"]:
        nameColors = oldConfig["annotations"].get("name-colors", {})
        newCustom = _loadPisaAnnotations(oldConfig["annotations"]["bed-name"],
                                         nameColors,
                                         oldCoords["genome-window-start"],
                                         oldCoords["genome-window-chrom"],
                                         newConfig["pisa"]["values"].shape[1])
        newConfig["annotations"]["name-colors"] = nameColors  # nameColors was mutated!
        newConfig["annotations"]["custom"] = newConfig["annotations"]["custom"] + newCustom

    if "genome-fasta" in oldCoords:
        newCoords["sequence"] = _loadSequence(
            oldCoords["genome-fasta"],
            oldCoords["genome-window-start"],
            oldCoords["genome-window-chrom"],
            newConfig["pisa"]["values"].shape[1])
    else:
        newCoords["sequence"] = oldCoords["sequence"]
    return newConfig


def _loadFromBigwig(bwFname: str, start: int, chrom: str, length: int) -> PRED_AR_T:
    impFp = pyBigWig.open(bwFname)
    impScores = np.nan_to_num(impFp.values(chrom, start, start + length))
    impFp.close()
    return impScores


def _normalizeProfileColor(colorSpec: DNA_COLOR_SPEC_T | COLOR_SPEC_T |  # noqa
                                      list[DNA_COLOR_SPEC_T | COLOR_SPEC_T],  # noqa
                           numItems: int) -> list[DNA_COLOR_SPEC_T]:
    match colorSpec:
        case {"A": aColor, "C": cColor, "G": gColor, "T": tColor}:
            a = aColor
            c = cColor
            g = gColor
            t = tColor
        case list():
            ret = []
            for cv in colorSpec:
                if "A" in cv:
                    ret.append(cv)
                else:
                    ret.append({"A": cv, "C": cv, "G": cv, "T": cv})
            return ret
        case _:
            color: COLOR_SPEC_T = colorSpec  # type: ignore
            a = c = g = t = color
    colorDict: DNA_COLOR_SPEC_T = {"A": a, "C": c, "G": g, "T": t}
    return [colorDict] * numItems


def _loadSequence(genomeFastaFname: str, genomeWindowStart: int,
                  genomeWindowChrom: str, length: int) -> str:
    with pysam.FastaFile(genomeFastaFname) as genome:
        seq = genome.fetch(genomeWindowChrom, genomeWindowStart, genomeWindowStart + length)
    return seq.upper()


def _loadPisaAnnotations(bedFname: str, nameColors: dict[str, COLOR_SPEC_T],
                         start: int, chrom: str, length: int) -> list[dict]:
    annotations = []
    bedFp = pybedtools.BedTool(bedFname)
    for line in bedFp:
        if line.chrom == chrom and line.end > start\
                and line.start < start + length:
            if line.name not in nameColors:
                nameColors[line.name] = \
                    {"tol-light": len(nameColors) % len(ColorMaps.tolLight)}
            if line.start < start:
                line.start = start
            if line.end > start + length:
                line.end = start + length
            annotations.append({
                "start": line.start,
                "end": line.end,
                "name": line.name,
                "color": nameColors[line.name]
            })
    return annotations


def _addVerticalProfilePlot(profile: PRED_AR_T, axProfile: AXES_T,
                            colors: list[DNA_COLOR_SPEC_T], sequence: str,
                            fontsize: int, fontSizeAxLabel: int, mini: bool):
    plotProfile = list(profile)
    for pos, val in enumerate(plotProfile):
        y = len(plotProfile) - pos
        axProfile.fill_betweenx([y, y + 1], val, step="post",
                                color=ColorMaps.parseSpec(colors[pos][sequence[pos]]))
    axProfile.set_ylim(0, len(profile))
    axProfile.set_xlim(0, float(np.max(profile)))
    if mini:
        axProfile.set_xticks([])
        axProfile.xaxis.set_visible(False)
    else:
        profileXticks = axProfile.get_xticks()
        if max(profileXticks) > np.max(profile) * 1.01:
            profileXticks = profileXticks[:-1]
        axProfile.set_xticks(profileXticks, profileXticks, fontsize=fontsize,
                             fontfamily=FONT_FAMILY)
        axProfile.set_xlabel("Profile", fontsize=fontSizeAxLabel, fontfamily=FONT_FAMILY)


def _addAnnotations(axAnnot: AXES_T, annotations: dict, boxHeight: float,
                    genomeStartX: int, genomeEndX: int, cutLengthX: int,
                    fontsize: int, mini: bool) -> dict[str, COLOR_SPEC_T]:
    offset = -boxHeight * 1.3
    lastR = 0
    usedNames = {}
    for annot in sorted(annotations, key=lambda x: x["start"]):
        aleft = annot["start"]
        aright = annot["end"]
        if aright < genomeStartX or aleft > genomeEndX:
            continue
        # No directly abutting annotations - at least 1%
        if aleft > lastR + cutLengthX / 100:
            offset = -boxHeight * 1.3
        lastR = max(lastR, aright)
        if offset < -1:
            # We're off the page - reset offset and deal with the overlap.
            offset = -boxHeight * 1.3
        axAnnot.fill([aleft, aleft, aright, aright],
                     [offset, boxHeight + offset, boxHeight + offset, offset],
                     label=annot["name"], color=ColorMaps.parseSpec(annot["color"]))
        if not mini:
            axAnnot.text((aleft + aright) / 2, offset + boxHeight / 2, annot["name"],
                     fontstyle="italic", fontsize=fontsize, fontfamily=FONT_FAMILY,
                     ha="center", va="center")
        usedNames[annot["name"]] = annot["color"]
        offset -= boxHeight * 1.5
    axAnnot.set_xlim(genomeStartX, genomeEndX)
    return usedNames


def _addPisaPlot(shearMat: IMPORTANCE_AR_T, colorSpan: float, axPisa: AXES_T,
                 diagMode: Literal["on"] | Literal["off"] | Literal["edge"],
                 gridMode: Literal["on"] | Literal["off"], fontsize: int,
                 fontSizeAxLabel: int, genomeWindowStart: int, mini: bool) -> ScalarMappable:

    xlen = shearMat.shape[1]
    axStartY = (xlen - shearMat.shape[0]) // 2
    axStopY = axStartY + shearMat.shape[0]
    cmap = ColorMaps.pisaClip

    plotMat = np.array(shearMat)
    plotMat *= math.log10(math.e) * 10
    colorSpan *= math.log10(math.e) * 10
    extent = (0, xlen, axStopY, axStartY)
    axPisa.imshow(plotMat, vmin=-colorSpan, vmax=colorSpan, extent=extent,
                  cmap=cmap, aspect="auto", interpolation="nearest")

    match diagMode:
        case "off":
            pass
        case "on":
            axPisa.plot([0, xlen], [0, xlen], "k--", lw=0.5)
        case "edge":
            if xlen > shearMat.shape[0]:
                # We have a wide plot, so clip in appropriately.
                xStart = (xlen - shearMat.shape[0]) // 2
                xEnd = xlen - xStart
            else:
                xStart = 0
                xEnd = xlen
            axPisa.plot([xStart, xStart + xlen * 0.02], [xStart, xStart + xlen * 0.02],
                        "k-", lw=2.0)
            axPisa.plot([xEnd - xlen * 0.02, xEnd], [xEnd - xlen * 0.02, xEnd], "k-", lw=2.0)
    if not mini:
        axPisa.set_ylabel("Output base coordinate", fontsize=fontSizeAxLabel,
                      fontfamily=FONT_FAMILY, labelpad=-5)
    numYTicks = 4 if mini else 10
    ticksY, tickLabelsY = getCoordinateTicks(genomeWindowStart,
                      genomeWindowStart + shearMat.shape[0], numYTicks, True)
    ticksY = [x + axStartY for x in ticksY]
    axPisa.set_yticks(ticksY, tickLabelsY, fontsize=fontsize, fontfamily=FONT_FAMILY)
    axPisa.set_ylim(axStopY, axStartY)
    match gridMode:
        case "on":
            axPisa.grid()
        case "off":
            pass
    norm = mplcolors.Normalize(vmin=-colorSpan, vmax=colorSpan)
    smap = ScalarMappable(norm=norm, cmap=cmap)
    return smap


def _addCbar(pisaCax: ScalarMappable, axCbar: AXES_T, fontsize: int, mini: bool):
    cbar = plt.colorbar(mappable=pisaCax, cax=axCbar)
    bottom, top = axCbar.get_ylim()
    axCbar.set_yticks(cbar.get_ticks(), [f"{x:0.1f}" for x in cbar.get_ticks()],
                      fontsize=fontsize, fontfamily=FONT_FAMILY)
    axCbar.set_ylim(bottom, top)
    if mini:
        axCbar.set_xlabel("PISA\neffect\n(dBr)", fontsize=fontsize, fontfamily=FONT_FAMILY)
    else:
        axCbar.set_xlabel("PISA effect\n(dBr)", fontsize=fontsize, fontfamily=FONT_FAMILY)


def _addLegend(usedNames: dict[str, COLOR_SPEC_T], axLegend: AXES_T, fontsize: int):
    offset = 1
    for name, color in usedNames.items():
        axLegend.fill([0, 0, 1, 1],
                      [offset, offset + 1, offset + 1, offset],
                      color=ColorMaps.parseSpec(color))
        axLegend.text(0.5, offset + 0.5, name, fontstyle="italic",
                      fontsize=fontsize, fontfamily=FONT_FAMILY,
                      ha="center", va="center")
        offset += 2
    axLegend.set_xlim(0, 1)
    axLegend.set_ylim(0, max(5, offset - 1))


def _getPisaAxes(fig: matplotlib.figure.Figure, left: float, bottom: float,
                 width: float, height: float, mini: bool) -> tuple[AXES_T, AXES_T,
        AXES_T, AXES_T, AXES_T, AXES_T | None]:
    xweightPisa = 40
    xweightProfile = 6
    xweightCbar = 3 if mini else 1
    widthScale = 1
    totalWeight = xweightPisa + xweightProfile + xweightCbar
    pisaWidth = width * xweightPisa / totalWeight * widthScale
    profileWidth = width * xweightProfile / totalWeight * widthScale
    cbarWidth = width * xweightCbar / totalWeight * widthScale
    pisaHeight = height * 7 / 8
    seqHeight = height / 8

    axPisa = fig.add_axes((left, bottom + seqHeight, pisaWidth, pisaHeight))
    axSeq = fig.add_axes((left, bottom, pisaWidth, seqHeight))
    axProfile = fig.add_axes((left + pisaWidth + profileWidth * 0.02,
                              bottom + seqHeight, profileWidth * 0.9, pisaHeight))
    axCbar = fig.add_axes((left + pisaWidth + profileWidth,
                           bottom + seqHeight + pisaHeight / (8 if mini else 4),
                           cbarWidth, pisaHeight / (3 if mini else 2)))
    axLegend = None
    if mini:
        axLegend = fig.add_axes((left + pisaWidth + profileWidth,
                            bottom + seqHeight + pisaHeight * (1 / 3 + 1 / 7),
                            cbarWidth * 3, pisaHeight * (1 - 1 / 3 - 1 / 7)))
        axLegend.set_axis_off()
    axAnnot = fig.add_axes((left,
                            bottom + seqHeight + 2 * pisaHeight / 3,
                            pisaWidth,
                            pisaHeight / 3))
    axAnnot.set_axis_off()

    axSeq.set_frame_on(False)
    axSeq.set_yticks([])
    axAnnot.set_ylim(-1, 0)
    axAnnot.set_axis_off()
    axProfile.set_yticks([])
    axProfile.set_frame_on(False)
    axProfile.yaxis.set_visible(False)
    return axPisa, axSeq, axProfile, axCbar, axAnnot, axLegend


def _getPisaGraphAxes(fig: matplotlib.figure.Figure, left: float, bottom: float, width: float,
                      height: float) -> tuple[AXES_T, AXES_T, AXES_T, AXES_T, AXES_T]:
    #  |  .   ..  . |  ‚Üë
    #  | .:  .::  : |  | profileHeight
    #  --------------  ‚Üì
    #                   ‚Üï profileSpace
    #  --------------  ‚Üë
    #  |   |        |  |  graphHeight
    #  |    \       |  |
    #  |     \      |  |
    #  |   nanog    |  |  ‚Üï annotHeight
    #  |      |     |  |   ‚Üï annotOffset
    #  --------------  ‚Üì
    #                    ‚Üï seqSpace
    #  ___C_aTCa_____  ‚Üï seqHeight
    # 105          131

    # Get the actual width of the graph so that it matches pisa plots.
    # These numbers should match _getPisaAxes.
    graphXWeight = 40
    profileXWeight = 6
    cbarXWeight = 1
    totalXWeight = graphXWeight + profileXWeight + cbarXWeight
    graphWidth = width * graphXWeight / totalXWeight
    cbarWidth = width * cbarXWeight / totalXWeight
    graphŒª = 8
    profileŒª = 1
    seqŒª = 1
    offsetFracAnnot = 0.01  # Relative to the height of the graph, not bbox.
    heightFracAnnot = 0.2  # ditto.
    spacingŒª = 0.05

    # Now we get the heights.
    totalŒª = graphŒª + profileŒª + seqŒª + 2 * spacingŒª
    Œ¥ = height / totalŒª  # This gives us the units for positioning.
    seqBase = 0
    seqHeight = Œ¥ * seqŒª
    space = Œ¥ * spacingŒª
    graphBase = seqBase + seqHeight + space
    graphHeight = Œ¥ * graphŒª
    profileBase = graphBase + graphHeight + space
    profileHeight = Œ¥ * profileŒª
    annotBase = graphBase + graphHeight * offsetFracAnnot
    annotHeight = graphHeight * heightFracAnnot

    axImportance = fig.add_axes((left, bottom + seqBase, graphWidth, seqHeight))
    axGraph = fig.add_axes((left, bottom + graphBase, graphWidth, graphHeight))
    axPredictions = fig.add_axes((left, bottom + profileBase,
                              graphWidth, profileHeight))

    axCbar = fig.add_axes((left + width - cbarWidth,
                           bottom + graphBase + graphHeight / 4,
                           cbarWidth, graphHeight / 2))

    axAnnot = fig.add_axes((left, bottom + annotBase, graphWidth, annotHeight))
    axAnnot.set_axis_off()
    axGraph.set_yticks([])
    axPredictions.set_xticks([])
    axPredictions.set_yticks([])
    axPredictions.set_frame_on(False)
    axImportance.set_frame_on(False)
    axImportance.set_yticks([])
    axAnnot.set_ylim(0, -1)

    return axGraph, axImportance, axPredictions, axAnnot, axCbar


def _addHorizontalProfilePlot(values: PRED_AR_T, colors: list[DNA_COLOR_SPEC_T], seq: str,
                              genomeStartX: int, genomeEndX: int, axSeq: AXES_T,
                              axGraph: AXES_T | None, fontSizeTicks: int, fontSizeAxLabel: int,
                              showSequence: bool, labelAxis: bool, mini: bool):
    numXTicks = 4 if mini else 10
    ticksX, tickLabelsX = getCoordinateTicks(genomeStartX, genomeEndX, numXTicks, True)

    axSeq.set_xlim(0, values.shape[0])
    if showSequence:
        # We have a short enough window to draw individual letters.
        seqOhe = utils.oneHotEncode(seq) * 1.0
        for i in range(len(seq)):
            seqOhe[i, :] *= values[i]
        # Draw the letters.
        plotLogo(seqOhe, len(seq), axSeq, colors=colors)
        axSeq.set_ylim(float(np.min(seqOhe)), float(np.max(seqOhe)))
    else:
        # Window span too big - just show a profile.
        for pos, score in enumerate(values):
            axSeq.bar([pos], [score],
                      linewidth=1, facecolor=ColorMaps.parseSpec(colors[pos][seq[pos]]),
                      edgecolor=ColorMaps.parseSpec(colors[pos][seq[pos]]))
        axSeq.plot([0, values.shape[0]], [0, 0], "k--", lw=0.5)
    if labelAxis:
        axSeq.set_xticks(ticksX, tickLabelsX, fontsize=fontSizeTicks, fontfamily=FONT_FAMILY)

        axSeq.xaxis.set_tick_params(labelbottom=True, which="major")
        axSeq.set_ylabel("Contrib.\nscore", fontsize=fontSizeAxLabel,
                        fontfamily=FONT_FAMILY, rotation=0, loc="bottom", labelpad=40)
        axSeq.set_xlabel("Input base coordinate", fontsize=fontSizeAxLabel,
                         fontfamily=FONT_FAMILY)
        if axGraph is not None:
            axGraph.set_xticks(ticksX)
            axGraph.tick_params(axis="x", which="major", length=0, labelbottom=False)


def _addPisaGraph(similarityMat: IMPORTANCE_AR_T, minValue: float, colorSpan: float,
                  colorBlocks: list[tuple[int, int, tuple[float, float, float]]],
                  lineWidth: float, ax: AXES_T) -> ScalarMappable:
    """Draw a graph representation of a PISA matrix.

    :param similarityMat: The PISA array, already sheared. It should be square.
    :param minValue: PISA values less than this will not be plotted at all.
    :param colorSpan: Values higher than this will be clipped.
    :param colorBlocks: Regions of the plot that override the color of the lines.
        These are tuples of (start, end, (r, g, b)).
        If the origin of a line overlaps with a ColorBlock, then its color is set
        to the rgb color in the block.
    :param lineWidth: The thickness of the drawn lines. For large figures,
        thicker lines avoid Moir√© patterns.
    :param ax: The axes to draw on. The xlim and ylim will be clobbered by this function.
    """
    cmap = ColorMaps.pisaClip

    plotMat = np.array(similarityMat)
    # convert into dB
    plotMat *= math.log10(math.e) * 10
    colorSpan *= math.log10(math.e) * 10
    minValue *= math.log10(math.e) * 10

    def addLine(xLower, xUpper, value):
        if abs(value) < minValue:
            return False
        if value < 0:
            value += minValue
        elif value > 0:
            value -= minValue
        if value > colorSpan:
            value = colorSpan
        if value < -colorSpan:
            value = -colorSpan
        xmax = 1
        turnPoint = 0.5
        verts = [
            (xLower + 0.5, 0.),
            (xLower + 0.5, xmax * turnPoint),
            (xUpper + 0.5, xmax * turnPoint),
            (xUpper + 0.5, xmax)]
        codes = [
            Path.MOVETO,
            Path.CURVE4,
            Path.CURVE4,
            Path.CURVE4]
        path = Path(verts, codes)
        normValue = (value + colorSpan) / (2 * colorSpan)
        normŒ± = abs(value / colorSpan)

        color = cmap(normValue, alpha=normŒ±)
        for colorBlock in colorBlocks:
            start, end, colorSpec = colorBlock
            r, g, b = ColorMaps.parseSpec(colorSpec)[:3]
            if start <= xLower < end:
                color = (r, g, b, normŒ±)
                break

        curPatch = patches.PathPatch(path, facecolor="none", lw=lineWidth,
                                     edgecolor=color)
        return (abs(value), curPatch)
    patchList = []

    for row in logUtils.wrapTqdm(range(plotMat.shape[0]), "DEBUG"):
        for col in range(plotMat.shape[1]):
            if curPatch := addLine(col, row, plotMat[row, col]):
                patchList.append(curPatch)
    psSorted = sorted(patchList, key=lambda x: x[0])
    for p in logUtils.wrapTqdm(psSorted, "DEBUG"):
        ax.add_patch(p[1])
    ax.set_xlim(0, np.max(plotMat.shape))
    ax.set_ylim(0, 1)

    # Last quick thing to do - generate a color map.
    norm = mplcolors.Normalize(vmin=-colorSpan, vmax=colorSpan)
    smap = ScalarMappable(norm=norm, cmap=cmap)
    return smap


# Copyright 2022, 2023, 2024 Charles McAnany. This file is part of BPReveal. BPReveal is free software: You can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version. BPReveal is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with BPReveal. If not, see <https://www.gnu.org/licenses/>.  # noqa

#!/usr/bin/env python3
import h5py
import pyBigWig
import scipy.special
import numpy as np
import argparse

def writeBigWig(inH5, outFname, mode):
    bwHeader = []
    for i, name in enumerate(inH5["chrom_names"].asstr()):
        bwHeader.append(("{0:s}".format(name), inH5['chrom_sizes'][i]))
    outBw = pyBigWig.open(outFname, 'w')
    outBw.addHeader(bwHeader)

    numRegions = inH5['coords_chrom'].shape[0]
    #Sort the regions. 
    regionOrder = sorted(range(numRegions), key = lambda x: (inH5['coords_chrom'][i], inH5['coords_start'][i]))
    curChrom = 0
    startWritingAt = 0
    regionID = regionOrder[0]
    regionChrom = inH5['coords_chrom'][regionID]
    regionStart = inH5['coords_start'][regionID]
    regionStop = inH5['coords_stop'][regionID]

    for regionNumber in range(numRegions):
        #Extract the appropriate region from the sorted list. 

        if(regionChrom != curChrom):
            curChrom = regionChrom
            startWritingAt = 0

        if(startWritingAt < regionStart):
            #The next region starts beyond the end 
            #of the previous one. Some bases will not be filled in.
            startWritingAt = regionStart
        #By default, write the whole region. 
        stopWritingAt = regionStop
        #As long as we aren't on the last region, check for overlaps.
        if(regionNumber < numRegions-1):
            nextRegion = regionOrder[regionNumber+1]
            nextChrom = inH5['coords_chrom'][nextRegion]
            nextStart = inH5['coords_start'][nextRegion]
            nextStop = inH5['coords_stop'][nextRegion]
            if(nextChrom == regionChrom and nextStart < stopWritingAt):
                #The next region overlaps. So stop writing before then. 
                overlapSize = regionStop - nextStart
                stopWritingAt = stopWritingAt - overlapSize //2
        dataSliceStart = startWritingAt - regionStart
        dataSliceStop = stopWritingAt - regionStart
        
        #Okay, now it's time to actually do the thing to the data! 
        match mode:
            case 'profile':
                logits = inH5['logits'][regionID]
                logCounts = inH5['counts'][regionID]
                profileProb = scipy.special.softmax(logits)
                profile = profileProb * np.exp(logCounts)
            case 'logits':
                profile = inH5['logits'][regionID]
            case 'logcounts':
                profile = np.zeros((regionStop - regionStart)) + inH5['counts'][regionID]
            case 'counts':
                profile = np.zeros((regionStop - regionStart)) + np.exp(inH5['counts'][regionID])
        #print("Adding at {0:d} - {1:d} ({2:d} - {3:d})".format(startWritingAt, stopWritingAt, dataSliceStart, dataSliceStop))
        vals = [float(x) for x in profile[dataSliceStart:dataSliceStop]]
        #print(vals[:10])
        outBw.addEntries(bwHeader[regionChrom][0], 
                startWritingAt,
                values = vals,
                span=1, step=1)

        #Update the region. By pulling the first setting of the region variables out of the loop,
        #I avoid double-dipping to get those data from the H5. 
        startWritingAt = stopWritingAt
        regionID = nextRegion
        regionChrom = nextChrom
        regionStart = nextStart
        regionStop = nextStop
    outBw.close()

def main():
    parser = argparse.ArgumentParser(description='Take an hdf5-format file generated by the predict script and render it to a bigwig.')
    parser.add_argument("--h5", help='The name of the hdf5-format file to be read in.')
    parser.add_argument("--bw", help='The name of the bigwig file that should be written.')
    parser.add_argument("--mode", help='What do you want written? Options are "profile", meaning you want (softmax(logits) * exp(logcounts)), or "logits", meaning you just want logits, or "logcounts", meaning you want the log counts for every region, or "counts", meaning you want exp(logcounts). You will usually want "profile"')
    args = parser.parse_args()
    inH5 = h5py.File(args.h5, 'r')
    writeBigWig(inH5, args.bw, args.mode)

if(__name__ == "__main__"):
    main()


